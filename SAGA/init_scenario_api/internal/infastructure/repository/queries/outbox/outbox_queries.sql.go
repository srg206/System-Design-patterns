// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: outbox_queries.sql

package outbox

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOutboxScenario = `-- name: CreateOutboxScenario :one
INSERT INTO outbox_scenario (
    outbox_uuid,
    scenario_uuid,
    payload
) VALUES (
    $1, $2, $3
) RETURNING outbox_uuid, scenario_uuid, payload, state, created_at, updated_at, locked_until
`

type CreateOutboxScenarioParams struct {
	OutboxUuid   pgtype.UUID `json:"outbox_uuid"`
	ScenarioUuid pgtype.UUID `json:"scenario_uuid"`
	Payload      []byte      `json:"payload"`
}

func (q *Queries) CreateOutboxScenario(ctx context.Context, arg CreateOutboxScenarioParams) (OutboxScenario, error) {
	row := q.db.QueryRow(ctx, createOutboxScenario, arg.OutboxUuid, arg.ScenarioUuid, arg.Payload)
	var i OutboxScenario
	err := row.Scan(
		&i.OutboxUuid,
		&i.ScenarioUuid,
		&i.Payload,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LockedUntil,
	)
	return i, err
}

const getPendingOutboxScenarios = `-- name: GetPendingOutboxScenarios :many
SELECT outbox_uuid, scenario_uuid, payload, state, created_at, updated_at, locked_until FROM outbox_scenario
WHERE state = 'pending'
  AND (locked_until IS NULL OR locked_until <= NOW())
ORDER BY created_at ASC
LIMIT $1
FOR UPDATE SKIP LOCKED
`

func (q *Queries) GetPendingOutboxScenarios(ctx context.Context, limit int32) ([]OutboxScenario, error) {
	rows, err := q.db.Query(ctx, getPendingOutboxScenarios, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OutboxScenario{}
	for rows.Next() {
		var i OutboxScenario
		if err := rows.Scan(
			&i.OutboxUuid,
			&i.ScenarioUuid,
			&i.Payload,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LockedUntil,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockOutboxScenario = `-- name: LockOutboxScenario :exec
UPDATE outbox_scenario
SET locked_until = $2,
    updated_at = NOW()
WHERE outbox_uuid = $1
`

type LockOutboxScenarioParams struct {
	OutboxUuid  pgtype.UUID      `json:"outbox_uuid"`
	LockedUntil pgtype.Timestamp `json:"locked_until"`
}

func (q *Queries) LockOutboxScenario(ctx context.Context, arg LockOutboxScenarioParams) error {
	_, err := q.db.Exec(ctx, lockOutboxScenario, arg.OutboxUuid, arg.LockedUntil)
	return err
}

const lockOutboxScenariosBatch = `-- name: LockOutboxScenariosBatch :exec
UPDATE outbox_scenario
SET locked_until = NOW() + INTERVAL '1 minute',
    updated_at = NOW()
WHERE outbox_uuid = ANY($1::uuid[])
`

func (q *Queries) LockOutboxScenariosBatch(ctx context.Context, dollar_1 []pgtype.UUID) error {
	_, err := q.db.Exec(ctx, lockOutboxScenariosBatch, dollar_1)
	return err
}

const markOutboxScenariosAsSentBatch = `-- name: MarkOutboxScenariosAsSentBatch :exec
UPDATE outbox_scenario
SET state = 'sent',
    locked_until = NULL,
    updated_at = NOW()
WHERE outbox_uuid = ANY($1::uuid[])
`

func (q *Queries) MarkOutboxScenariosAsSentBatch(ctx context.Context, dollar_1 []pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markOutboxScenariosAsSentBatch, dollar_1)
	return err
}

const updateOutboxScenarioState = `-- name: UpdateOutboxScenarioState :exec
UPDATE outbox_scenario
SET state = $2,
    updated_at = NOW()
WHERE scenario_uuid = $1
`

type UpdateOutboxScenarioStateParams struct {
	ScenarioUuid pgtype.UUID `json:"scenario_uuid"`
	State        *string     `json:"state"`
}

func (q *Queries) UpdateOutboxScenarioState(ctx context.Context, arg UpdateOutboxScenarioStateParams) error {
	_, err := q.db.Exec(ctx, updateOutboxScenarioState, arg.ScenarioUuid, arg.State)
	return err
}
